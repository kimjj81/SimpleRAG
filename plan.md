# SimpleRAG 프로젝트 계획

이 문서는 검색 증강 생성(Retrieval-Augmented Generation, RAG) 시스템인 SimpleRAG 프로젝트 개발 계획을 간략하게 설명합니다.

### 1. 프론트엔드 (사용자 인터페이스)
- **1.1 Streamlit을 이용한 채팅 UI**
  - 경량 Python 기반 프론트엔드를 위해 Streamlit을 사용하여 채팅 인터페이스를 개발합니다.
  - 메시지 기록 표시 기능이 있는 실시간 채팅 기능을 구현합니다.
  - 다양한 형식(docx, txt, md, excel)의 파일 업로드 기능을 활성화합니다.
  - 채팅 세션 관리(새로 시작, 이전 내용 보기, 이어하기)를 위한 직관적인 UI를 디자인합니다.
- **1.2 파일 업로드 처리**
  - 지원되는 형식에 대한 유효성 검사와 함께 여러 파일 업로드를 지원합니다.
  - 업로드 상태(성공, 실패, 파일 너무 큼 등)에 대한 피드백을 제공합니다.
  - 사용자가 참조할 수 있도록 업로드된 파일을 UI에 표시합니다.
- **1.3 채팅 세션 관리**
  - 채팅 기록을 저장하고 검색하기 위해 세션 저장소를 구현합니다.
  - 사용자가 새 세션을 시작하고, 이전 세션 목록을 보고, 기존 세션을 계속할 수 있도록 합니다.
  - 개인화된 액세스를 위해 세션 데이터가 사용자 계정과 연결되도록 합니다.

### 2. 백엔드 UI (Next.js를 이용한 관리자 인터페이스)
- **2.1 Next.js 프레임워크**
  - 성능을 위해 서버 측 렌더링을 사용하는 React 기반 관리자 대시보드에 Next.js를 사용합니다.
  - 다양한 관리자 섹션(사용자 관리, 파일 관리, 모델 관리)에 대한 라우팅을 설정합니다.
- **2.2 사용자 관리**
  - 사용자 정보(이름, 이메일, 비밀번호 변경)를 보고 편집할 수 있는 페이지를 만듭니다.
  - 역할 기반 접근 제어(관리자 대 일반 사용자)를 구현합니다.
- **2.3 업로드된 파일 관리**
  - 메타데이터(파일명, 크기, 업로드 날짜, 소유자)와 함께 업로드된 파일 목록을 표시합니다.
  - 관리자가 파일을 삭제하거나 다운로드할 수 있도록 합니다.
- **2.4 모델 관리**
  - RAG에 사용되는 LLM 모델을 구성하고 모니터링하는 인터페이스를 제공합니다.
  - 활성 모델 선택, 사용 통계 보기, API 키 업데이트 옵션을 포함합니다.

### 3. 백엔드 (Django를 이용한 핵심 기능)
- **3.1 Django 프레임워크**
  - 강력한 백엔드 로직, 인증 및 API 서비스를 위해 Django를 사용합니다.
  - 사용자, 파일, 채팅 및 RAG 처리를 위한 앱으로 프로젝트를 구성합니다.
- **3.2 LLM 호출 API**
  - LLM 서비스(LangChain, Gemini API, LM Studio)와 상호 작용하는 엔드포인트를 개발합니다.
  - LLM API의 재시도, 시간 초과 및 오류 응답을 처리하는 로직을 구현합니다.
- **3.3 사용자 UI용 API**
  - 채팅 상호 작용, 파일 업로드 및 세션 관리를 처리하기 위해 Streamlit 프론트엔드용 RESTful API를 만듭니다.
  - 적절한 직렬화 및 유효성 검사를 통해 API 개발을 위해 Django REST Framework를 사용합니다.
- **3.4 회원 가입**
  - ID/비밀번호 및 Google OAuth 로그인으로 사용자 인증을 구현합니다.
  - 새 계정에 대한 비밀번호 재설정 기능 및 이메일 확인을 포함합니다.
- **3.5 채팅 기록 관리**
  - 타임스탬프, 사용자 ID 및 세션 ID와 함께 채팅 메시지를 데이터베이스에 저장합니다.
  - 채팅 기록을 검색하고 저장하는 API를 제공합니다.
- **3.6 청킹, 임베딩 및 작업 관리**
  - 업로드된 파일을 처리하기 위한 파이프라인을 개발합니다: 텍스트 청킹, 임베딩 생성 및 OpenSearch에 저장.
  - Celery와 같은 작업 큐 시스템으로 작업 상태(대기, 진행 중, 완료, 실패)를 추적합니다.
  - UI를 통해 사용자에게 작업 완료 또는 실패를 알립니다.

### 4. 인프라 및 구성
- **4.1 로컬 배포를 위한 Docker Compose**
  - 프론트엔드(Streamlit), 백엔드 UI(Next.js), 백엔드(Django), 데이터베이스(PostgreSQL) 및 검색(OpenSearch 3) 서비스를 정의하기 위해 `docker-compose.yml` 파일을 만듭니다.
  - 구성을 위한 환경 변수를 사용하여 macOS 및 Linux에서 로컬 실행 호환성을 보장합니다.
- **4.2 데이터베이스 - PostgreSQL**
  - 관계형 데이터 저장(사용자, 채팅 기록, 파일 메타데이터)을 위해 PostgreSQL을 사용합니다.
  - 성능을 위해 적절한 인덱싱으로 데이터베이스 스키마를 설계합니다.
- **4.3 하이브리드 검색 및 저장소 - OpenSearch 3**
  - 텍스트 청크 및 임베딩을 저장하고 검색하기 위해 OpenSearch를 구성합니다.
  - 더 나은 검색 정확도를 위해 키워드 및 벡터 유사성을 결합한 하이브리드 검색을 구현합니다.
- **4.4 데이터 저장소 - 로컬 디스크**
  - 정의된 디렉토리 구조(예: `/data/uploads/user_id/filename`)로 로컬 디스크에 업로드된 파일을 저장합니다.
  - 오래되거나 사용하지 않는 파일에 대한 파일 크기 제한 및 정리 정책을 구현합니다.
- **4.5 LLM API 통합**
  - 오케스트레이션을 위해 LangChain, 고급 모델을 위해 Gemini API, 로컬 LLM 옵션을 위해 LM Studio와 통합합니다.
  - 환경 변수 또는 관리자 UI를 통해 API 키 및 모델 선택 구성을 허용합니다.

### 5. 추가 고려 사항
- **5.1 보안**
  - 모든 통신에 HTTPS를 구현합니다.
  - API 보안을 위해 JWT 또는 세션 기반 인증을 사용합니다.
  - 악성 콘텐츠를 방지하기 위해 파일 업로드를 살균합니다.
  - 해당되는 경우 사용자 데이터 처리에 대한 GDPR 준수를 보장합니다.
- **5.2 확장성**
  - 서비스를 마이크로서비스로 분리하여 증가된 부하를 처리하도록 시스템을 설계합니다.
  - 프로덕션에서 Django 및 Next.js 서비스에 로드 밸런싱을 사용합니다.
  - 채팅 기록과 같이 자주 액세스하는 데이터에 대해 캐싱(예: Redis)을 구현합니다.
- **5.3 오류 처리 및 로깅**
  - 파일 처리, LLM 호출 및 사용자 상호 작용에 대한 포괄적인 오류 처리를 개발합니다.
  - 디버깅 및 모니터링을 위해 중앙 집중식 로깅(예: ELK 스택 또는 간단한 파일 기반 로그 사용)을 설정합니다.
- **5.4 테스트**
  - Django 백엔드 로직(API 엔드포인트, RAG 파이프라인)에 대한 단위 테스트를 작성합니다.
  - 프론트엔드-백엔드 상호 작용에 대한 통합 테스트를 구현합니다.
  - 코드 품질 보증을 위해 CI/CD 파이프라인에서 자동화된 테스트를 사용합니다.
- **5.5 문서화**
  - Docker Compose를 사용한 로컬 개발을 위한 자세한 설정 지침을 제공합니다.
  - Swagger 또는 Postman 컬렉션과 같은 도구를 사용하여 API 엔드포인트를 문서화합니다.
  - 최종 사용자(Streamlit UI) 및 관리자(Next.js 대시보드)를 위한 사용자 가이드를 포함합니다.
- **5.6 성능 최적화**
  - 대용량 문서를 효율적으로 처리하기 위해 청킹 및 임베딩 프로세스를 최적화합니다.
  - 비동기 처리를 위해 비동기 처리(예: Celery를 사용한 파일 처리)를 사용합니다.
  - RAG에서 더 빠른 검색을 위해 OpenSearch 쿼리를 미세 조정합니다.

### 아키텍처 다이어그램

```mermaid
graph TD
    A[사용자] -->|채팅 및 파일 업로드| B(Streamlit 프론트엔드)
    A -->|관리자 접근| C(Next.js 관리자 UI)
    B -->|API 호출| D(Django 백엔드)
    C -->|API 호출| D
    D -->|데이터베이스 작업| E[PostgreSQL]
    D -->|검색 및 검색| F[OpenSearch 3]
    D -->|파일 저장소| G[로컬 디스크]
    D -->|LLM 통합| H{LangChain}
    H -->|모델 접근| I[Gemini API]
    H -->|로컬 모델| J[LM Studio]
    K[Docker Compose] -->|오케스트레이션| B
    K -->|오케스트레이션| C
    K -->|오케스트레이션| D
    K -->|오케스트레이션| E
    K -->|오케스트레이션| F
